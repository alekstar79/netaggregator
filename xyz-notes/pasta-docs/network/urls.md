# Структура URL, абсолютные и относительные ссылки

## Структура URL

[URL (wiki)](https://ru.wikipedia.org/wiki/URL)  - это указатель на какой-то ресурс (например файл или страницу), который позволяет его получить. Например, URL `http://example.com/some/file.txt` указывает на файл `/some/file.txt`, который располагается на сервере `example.com` и который можно получить с использованием протокола `http`.

Вообще, кроме URL есть еще [URI](https://ru.wikipedia.org/wiki/URI) - это более общее понятие, просто указатель на что-то. Например есть формат URI для указания ссылки на телефон `tel:+180012345678` и для указания ссылки на книгу по ее уникальному номеру ISBN: `isbn:1234567890`. Но в этом уроке мы будем разбирать только URL, использующие протокол `http` или `https`, то есть URL, указывающие на файл в интернете. 

URL состоит из таких частей: 

`<схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>`

Пример URL, содержащего все части: `http://ivan:12345@example.com:80/some/path?a=1&b=2#hash`. Обязательными в URL являются только схема и хост, все остальные части могут отсутствовать. Описание компонент: 

- (обяз.) **схема** (протокол, scheme, protocol) - указывает протокол с использованием которого можно получить файл
- *логин* (login, auth), *пароль* (password) - передаются на сервер в том случае, если доступ к ресурсу закрыт HTTP-авторизацией. Не стоит использовать эту возможность и указывать пароль в ссылке - это небезопасно.
- (обяз.) **хост** (host, domain name) - указывает сервер, на котором размещен ресурс
- *порт* (port) - может быть указан если соединение с сервером надо устанавливать на нестандартном порту (это почти никогда не требуется)
- *путь* (path) - указывает на интересующий нас ресурс на сервере
- *параметры* (строка запроса, query string) - может содержать дополнительные параметры, которые будут переданы на сервер. Обычно параметры пишутся через знак `=`, и разделяются символом `&`, например `?a=1&b=2&c=hello%20world`. Спецсимволы в именах и значениях параметров надо кодировать [процентным кодированием](https://ru.wikipedia.org/wiki/URL#.D0.9A.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_URL). В примере выше в фразе `hello world` пробел (который нельзя использовать в ссылке) закодирован кодом `%20`.
- *якорь* (anchor, хеш, hash) - указывает на id элемента на HTML-странице к которому надо прокрутить страницу после загрузки. Это позволяет дать ссылку, которая указывает например на середину документа. Также, якорь может содержать параметры, которые будут переданы скриптам на странице, например `#show_info=1`

## Абсолютные и относительные ссылки

Наверно ты помнишь из предыдущего раздела, что в URL есть минимум 2 обязательные части: схема и хост. 
URL, который начинается со схемы, называется *абсолютным*, или полным. Однако когда мы ставим ссылки на веб-странице, мы можем использовать *относительные* URL, где одна или несколько начальных компонент может быть пропущена. 

Вот пример. Допустим, у нас есть страница по адресу `http://example.com/long/path/1.html` и мы хотим на ней поставить ссылку на страницу `http://example.com/long/path/2.html`. Мы можем использовать относительный URL и вместо такой длинной ссылки написать `<a href="2.html">...</a>`. Браузер возьмет этот относительный URL (`2.html`), объединит его с адресом страницы (`http://example.com/long/path/1.html`) и получит в итоге `http://example.com/long/path/2.html`. Это процесс называется *разрешение* (резолвинг, resolve) относительного URL.

Вот правила, по которым из относительного URL получается абсолютный. Базовый URL — это в данном случае URL страницы, на которой расположена ссылка. Пусть в данном примере базовый URL везде будет `http://example.com/long/path/1.html`

### Правило 1 

Если абсолютный URL использует тот же протокол (или тот же протокол и хост), их можно пропустить. При этом относительный URL начинается с одного или 2 слешей (в зависимости от того, что пропущено):

Если относительный URL начинается с 2 слешей, то протокол берется из базового URL.
Если относительный URL начинается с 1 слеша, то протокол и хост (и порт, если он есть), берется из базового.

```
//another-example.com/start.html -> http://another-example.com/start.html 
(http: берется из базового URL)

/about?us=1                      -> http://example.com/about?us=1
/other/path/page.html            -> http://example.com/other/path/page.html
(схема и хост подставляется из базового URL)
```

### Правило 2

Если у URL и у базового URL совпадают все части в пути, кроме последнего (`/long/path/1.html` -> `/long/path/2.html`), то начало пути можно откинуть:

Если относительный URL начинается не со слеша `/`, знака вопроса `?`, решетки `#`, то протокол, хост и путь (кроме последнего компонента пути) берется из базового URL.

```
3.html              -> http://example.com/long/path/3.html
and/even/more?a=1   -> http://example.com/long/path/and/even/more?a=1
```

Если относительный URL начинается с одного или нескольких `../`, то из пути откидывается столько же компонентов справа. Если в URL содержится одна точка `./`, ее можно откинуть:

```
../way/home         -> http://example.com/long/way/home 
(/path было откинуто)
./././1.txt         -> http://example.com/long/path/1.txt
(./././ можно откинуть)
```

Если это тебе кажется не очень понятным, то вспомни, что путь к странице напоминает путь в файловой системе (папка `long`, в ней папка `path`, в ней файл `1.html`), `.` обозначает «остаться в текущей папке», а `..` обозначает «подняться на 1 уровень выше».

### Правило 3

Если протокол, хост и путь совпадают, то их можно не писать. По этой причине, пустой URL `<a href="">..</a>` указывает на ту же страницу.

```
?a=1&b=2            -> http://example.com/long/path/1.html?a=1&b=2
                    -> http://example.com/long/path/1.html
(пустая ссылка указывает на ту же самую страницу)
```

### Правило 4

Если адреса страниц различаются только хешем, можно писать только его

`#target  -> http://example.com/long/path/1.html#target`

Эти 4 правила могут показаться сложными на первый взгляд, но ты можешь попробовать запомнить, что  относительная ссылка отличается от абсолютной тем, что у нее откинут один или несколько компонентов слева. 

Почитать еще про относительные ссылки можно тут: http://htmlbook.ru/samhtml/ssylki/absolyutnye-i-otnositelnye-ssylki

## Задания для закрепления

Допустим на странице `http://example.com:81/some/page.html?a=1&b=2#hash` размещены относительные ссылки. Определи полный URL для этих ссылок

- `/test`
- `?x`
- `//test.example.com`
- `#test`
- `../1.txt`
- `./1.txt`

Запиши относительные URL для этих ссылок как можно короче:

- `http://example.com:81/1.txt`
- `http://test.example.com/1.txt`
- `http://example.com:81/some/page2.html#hash`
- `http://example.com:81/some/page.html?x=1`

## Составление и разбор URL в PHP

В PHP есть стандартные функции для создания URL и разбора на части. Разобрать URL на части можно функцией [parse_url](http://php.net/manual/ru/function.parse-url.php). Она вернет нужную часть URL или `null` если она отсутствует. Примеры: 

```php
var_dump(parse_url("http://example.com", PHP_URL_SCHEME)); // -> 'http'
var_dump(parse_url("http://example.com?a=1&b=2", PHP_URL_QUERY)); // -> 'a=1&b=2'
var_dump(parse_url("http://example.com", PHP_URL_QUERY)); // -> null
// Функция также может разбирать URL в котором часть компонент отсутствует
var_dump(parse_url("/test?a=1", PHP_URL_QUERY)); // -> 'a=1'
```

Для составления и кодирования параметров URL в PHP есть функция [http_build_query](http://php.net/manual/ru/function.http-build-query.php). Она получает на вход массив параметров, кодирует их процентным кодированием и собирает в строку. Пример: 

```php
var_dump(http_build_query(['a' => 1, 'b' => 'hello world', 'c' => '?#:/'])); 
// -> 'a=1&b=hello+world&c=%3F%23%3A%2F'
```

Раскодировать параметры из строки запроса в массив можно с помощью функции [parse_str](http://php.net/manual/ru/function.parse-str.php). Пример использования: 

```php
$array = [];
parse_str('a=1&b=hello+world&c=%3F%23%3A%2F', $array);
var_dump($array);  // -> ['a' => "1", 'b' => "hello world", 'c' => "?#:/"]
```

Также, в PHP есть 2 функции [urlencode](http://php.net/manual/ru/function.urlencode.php) и [urldecode](http://php.net/manual/ru/function.urldecode.php) для того, чтобы закодировать или раскодировать строку процентным кодированием. Если ты используешь `http_build_query`, эти функции тебе не нужны. Пример: 

```php
var_dump(urlencode('hello world :/? test')); // -> 'hello+world+%3A%2F%3F+test'
var_dump(urldecode('hello+world+%3A%2F%3F+test')); // -> 'hello world :/? test'
```

## Функции работы с URL в Javascript

В JS есть 2 функции для кодирования/раскодирования строки с помощью процентного кодирования: 

```js
console.log(encodeURIComponent('hello world :/? test')); 
// -> "hello%20world%20%3A%2F%3F%20test"
console.log(decodeURIComponent('hello%20world%20%3A%2F%3F%20test'));
// -> "hello world :/? test"
```

Больше функций для работы с URL в JS нет. Если тебе надо разбирать или собирать URL, стоит поискать какую-нибудь библиотеку, например:

- https://www.npmjs.com/package/url-parse
- http://habrahabr.ru/post/65407/
- https://gist.github.com/jlong/2428561


